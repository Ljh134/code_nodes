#include<stdio.h>
#include<string.h>
#include<math.h>
#include<stdlib.h>
// int main()
// {
//     printf("12+13 = %d",12+13);
//     return 0 ;
// } 

// 计算输出

//变量：
// #include<stdio.h>
// int main()
// {
//     int price = 0 , num = 0 , charge = 0;
//     printf("请输入单价：");
//     scanf("%d",&price);
//     // 输入，&取地址符
//     printf("请输入数量：");
//     scanf("%d",&num);
//     printf("请输入金额：");
//     scanf("%d",&charge);
//     int total;
//     total = price * num ;
//     printf("total = %d\n",total);
//     int change = charge - total ;
//     printf("找零 = %d",change);
//     return 0 ;

// }

// 多个变量的输入：
// #include<stdio.h>
// int main()
// {
//     int a = 0 , b = 0;
//     scanf("%d %d",&a,&b);        // 空格隔开则输入也要有空格·
//     printf("a = %d , b = %d\n",a,b);
//     int c , d = 0 ;
//     scanf("%d,%d",&c,&d);                // 逗号隔开则输入也要有逗号.   在scanf中引号内的东西必须原封不动的输入，包括结尾空格
//     printf("c = %d , d = %d\n",c,d);
//     return 0 ;
// }
 
// 常量：  const 变量形式 变量名（一般全大写）.     常量标准化后不能再修改
 //eg:    const int num = 10 

 //整数运算结果还是整数（无4舍5入）      整数和浮点数运算结果是浮点数
 //浮点数： double （双精度浮点数 ） 或 float（单精度浮点数）

 //输入输出：
//  整数： 
//  int
//  printf("%d",变量名);
//  scanf("%d",&变量名);
//     浮点数：
//     float  double
//     printf("%f",变量名);   // float和double都用%f
//     scanf("%lf",&变量名);    // float和double都用%f

 // 运算：  赋值也是一种运算，从右向左运行
    // eg:  a = b = c = 10 ;   等价于  a = (b = (c = 10)) ;
    // eg:  c = 1 + (a = b).    等价于 a = b ; c = 1 + a ;
    //单目运算： +  -  ++  --  !  ~    ++（只能用于变量，变量+1）。    --（变量-1） ：优先级最高
    //双目运算： +  -  *  /  %  <<  >>  &  |  ^  &&  ||  
    //三目运算：  

     
    //  a++ 先拿去用再自增1
    //  ++a 先自增1再拿去用
    // eg:  int a = 10 ;
    //      int b = a++ ;  // b = 10 , a = 11
    //      int c = ++a ;  // a = 12 , c = 12


    // if 语句：
    //格式：
    // if(条件表达式)
    // {
    //     语句体 ;
    // }
    // else
    // {
    //     语句体 ;
    // }

    //没有{}时，if或else只控制紧跟着的第一条语句,else与最近的if匹配，有{}时else与相应if匹配
    // else if(条件表达式)  可以有多个else if

    // eg:
    // if(a>b)                  //不用加分号！！！
    // {
    //     printf("a>b\n");
    // }
    // else
    // {
    //     printf("a<=b\n");
    // }

    //关系运算符： >  <  >=  <=  ==  !=
    // 从左往右计算，优先级低于算术运算符，高于赋值运算符，== 最低
    // eg:  6 > 5 > 4.  先算6>5，结果为1，再算1>4，结果为0

    // switch 语句：
    //格式：
    // switch(表达式)
    // {
    //     case 常量表达式1:  (表达式运算的结果)
    //         语句体1 ;
    //         break ;
    //     case 常量表达式2:
    //         语句体2 ;
    //         break ;
    //     ...
    //     default:
    //         语句体n ;
    //         break ;
    // }
    // break 语句：跳出switch语句体
    // default 可有可无
    // switch语句中表达式的值必须是整数或字符类型，不能是浮点数
    // case后面必须是常量表达式，不能是变量或范围
    // switch语句中不能定义变量
    // switch语句中不能嵌套switch语句
    // switch语句中不能嵌套定义变量
    //如果没有break语句，会继续执行后面的case语句，直到遇到break或switch语句体结束


    //eg:
    // int main() 
    // {
    //     int score = 0 ;
    //     printf("请输入成绩：");
    //     scanf("%d",&score);
        
    //     switch(score/10)
    //     {
    //         case 10 :
    //             printf("大佬请收下我的膝盖\n");
    //             break;
    //         case 9 :
    //             printf("niubi\n");
    //             break;
    //         case 8:
    //             printf("还行\n");
    //             break;
    //         default:
    //              printf("菜就多练\n");
    //     }
    
    
    // return 0 ;
    
    // }
     
//while语句：
    //格式：
    // while(条件表达式)
    // {
    //     语句体 ;
    // }
    // 先判断条件表达式是否为真，再执行语句体
    // 条件表达式为真则执行语句体，为假则跳出循环
    // 条件表达式结果非0为真，0为假
    // 语句体可有多条语句，有多条时必须用{}括起来
    // 语句体中必须有使条件表达式变为假的语句，否则会死循环

    // eg:
    // int main()
    // {
    //     int i = 0 ;
    //     int n = 0;
    //     printf("请输入一个整数：");
    //     scanf("%d",&i);
    //     while (i>0)
    //     {
    //         i /=10;
    //         n++;
    //     }
    //     printf("这个整数有%d位\n",n);
    //     return 0 ;
    // }

    //do...while语句：
    //格式：
    // do
    // {
    //     语句体 ;
    // }while(条件表达式);
    // 先执行语句体，再判断条件表达式是否为真
    // 条件表达式为真则继续执行语句体，为假则跳出循环
    // 条件表达式结果非0为真，0为假
    // 语句体可有多条语句，有多条时必须用{}括起来
    // 语句体中必须有使条件表达式变为假的语句，否则会死循环
    // do...while语句至少执行一次语句体 
     
    //rand(): 生成随机数 
    //格式：
    // #include<stdlib.h>
    // #include<time.h>
    // int main()
    // {
    // srand(time(0));   // 设置随机数种子
    // int num = rand() % 100 +1 ;   // 生成1-100的随机数
    // printf("%d\n",num);
    // return 0 ;
    // }


/*
注：time函数返回time_t类型值，通常是long
time函数接受一个time_t*类型参数，作为储存时间的地址，如果传入NULL则不储存值，只返回当前时间

*/


    
    // for循环语句：
    //格式：
    // for(表达式1; 条件表达式; 表达式2)
    // {
    //     语句体 ;
    // }
    // 先执行表达式1（初始条件），再判断条件表达式是否为真（循环执行的条件）
    // 条件表达式为真则执行语句体，为假则跳出循环
    // 执行完语句体后，执行表达式2（循环每轮要做的动作），再判断条件表达式是否为真
    // 如此循环往复，直到条件表达式为假跳出循环
    // 语句体可有多条语句，有多条时必须用{}括起来
    // 语句体中必须有使条件表达式变为假的语句，否则会死循环
    // for循环语句中表达式1和表达式2可省略
    // for循环语句中表达式1和表达式2可有多条语句，用逗号隔开
    // for循环语句中不能定义变量
    // for循环语句中不能嵌套定义变量
    // // eg:
    // int main()
    // {
    //     int i = 0;
    //     int x = 0;
    //     int define = 1 ;
    //     int range ;
    //     printf("输入上限：");
    //     scanf("%d",&range);
    //     printf("1到%d之间的素数有:\n",range);
    //     for (i = 1 ; i<= range ; i++)
    //     {
    //         for(x = 2 ; x < i ; x++)
    //         {
    //             if (i % x == 0)
    //             {
    //                 define = 0 ;
    //                 break;
    //             }
    //             else
    //             {
    //                 define = 1 ;
    //             }
    //         }
    //         if (define == 1 && i !=1)
    //         {
    //             printf("%d\n",i);
    //         }
    //     }
    // }
    

    // 跳出多重循环：
    // 方法一： break接力
    // 方法二： goto语句
    //格式：
    // goto 标签名 ;
    // ...
    // 标签名: 语句体 ;
    // 标签名后面必须有冒号，标签名必须是唯一的标识
    // 运行到goto语句时，跳转到标签名处继续执行(传送门)


    //数据类型：
    //  1、整数： char  short  int  long  long long
    //     - char: 1字节，-128~127      %c
    //     - short: 2字节，-32768~32767     %hd
    //     - int: 4字节，-21亿~21亿     %d
    //     - long: 4字节，-21亿~21亿    %ld
    //     - long long: 8字节，-9千万亿~9千万亿     %lld
    // 2、浮点数： float  double
    //     - float: 4字节，单精度，7位有效数字.  %f
    //     - double: 8字节，双精度，15~16位有效数字     %lf
    // 3、逻辑： _Bool
    //     - _Bool: 1字节，0或1
    // 4、指针
    // 5、自定义
    
    //unsigned 无符号类型，只能表示非负数
    // eg: unsigned int a ;  0~42亿
    //     unsigned char b ;  0~255
    //     unsigned short c ;  0~65535 


    // sizeof(): 计算数据类型或变量所占字节数
    //格式：
    // sizeof(数据类型或变量名) 

    //整数的输入与输出：
    // %d :int
    // %hd :short  
    // %ld :long
    // %lld :long long
    // %u :unsigned int
    // %hu :unsigned short
    // %lu :unsigned long
    // %llu :unsigned long long
    // %c :char
    // %hhu :unsigned char
    // %o :八进制整数
    // %x :十六进制整数（小写字母）
    

    //0开头数字代表8进制。  0x开头代表16进制
    // eg: 012 = 10.        0x12 = 18.

    //浮点数类型：
    // float : 4字节，单精度，7位有效数字  最小可表达1.2E-38，最大可表达3.4E+38
    // double : 8字节，双精度，15~16位有效数字。 最小可表达2.3E-308，最大可表达1.7E+308
    // long double : 16字节，扩展精度，19~20位有效数字
     
    //浮点数的输入与输出：
    // %f :float  double
    // %e :科学计数法表示的浮点数（小写e）
    // %E :科学计数法表示的浮点数（大写E）
    // %g :根据数值的大小自动选择%f或%e（小写e）
    // %G :根据数值的大小自动选择%f或%E（大写E）
    // %.nf :保留n位小数，四舍五入
    // %.ne :保留n位小数，四舍五入，科学计数法表示（小写e）
    // %.nE :保留n位小数，四舍五入，科学计数法表示（大写E）
    // %.ng :保留n位小数，四舍五入，根据数值的大小自动选择%f或%e（小写e）
    // %.nG :保留n位小数，四舍五入，根据数值的大小自动选择%f或%E（大写E
    //科学计数法：mEn或mEn  m为小数部分，E或e后面为指数部分
    // eg: 12345.6789 = 1.23456789E4

    //inf : 无穷大(是浮点数)
    //nan : 非数(是浮点数) 
    //sqrt() 计算平方根
    // fabs() 计算绝对值
    // pow(x,y) 计算x的y次方
    // ceil() 向上取整
    // floor() 向下取整
    // round() 四舍五入取整
    // #include<math.h>  //使用这些函数要包含头文件

    //浮点数的比较：
    // 浮点数不能直接用==或!=比较是否相等或不等
    // 浮点数的大小比较可以用> < >= <=
    // 浮点数相等比较的方法：  取两个浮点数的差的绝对值，如果小于一个很小的数（如0.00001），则认为两个浮点数相等
    // eg:
    // fabs(f1 - f2)< le - l2e ;  // le - lee为一个很小的数


    //字符类型：  （字符串）
    // char : 1字节，-128~127  %c
    // unsigned char : 1字节，0~255  %c

    // 逃逸字符：  \" 在双引号中表示双引号
    //            \' 在单引号中表示单引号
    //            \\ 表示反斜杠
    //            \n 换行
    //            \t 水平制表符（tab键）
    //            \r 回车
    //            \b 退格。如果后面没有字符则无效，如果有则替换
    //            \f 换页
    //            \v 垂直制表符
    //            \a 响铃
    //            \? 问号   （防止与三目运算符中的?混淆）

    //自动类型转换：
    //当运算符两边的数据类型不同时，先把数据类型低的转换为数据类型高的，再进行运算
    //数据类型从低到高依次为： char -> short -> int -> long -> long long -> float -> double -> long double
    //对于printf函数来说，float会自动提升为double  小于int的类型会自动提升为int
    //但scanf函数中没有自动提升
    //强制类型转换：
    //(数据类型)变量名或表达式
    // eg： （int）10.2 = 10
    //      （float）5 = 5.0
    //      （char）65 = 'A'
    //      （int）'A' = 65
 

    //bool类型：
    // #include<stdbool.h>        //包含头文件才能用
    //逻辑运算：
    //   ！ 非
    //   && 与
    //   || 或
    // 逻辑运算的优先级： ！ > && > || 
    //eg: 判断是否为大写字母：
    // if(c >= 'A' && c <= 'Z') 
    //逻辑短路：
    // 逻辑与运算时，如果第一个操作数为假，则不再计算第二个操作数，结果为假
    // 逻辑或运算时，如果第一个操作数为真，则不再计算第二个操作数，结果为真
    //不要把赋值包括复合赋值写进表达式 
    
    
    //条件运算符：
    //格式：
    // 表达式1 ? 表达式2 : 表达式3
    // 先计算表达式1，如果为真则计算表达式2并作为整个表达式的值，如果为假则计算表达式3并作为整个表达式的值


    //函数：    //格式：
    // 返回值类型 函数名(参数类型 参数名, ...)             （没有返回值时，返回值类型为void）
    // {
    //     语句体 ;
    //     return 返回值 ;
    // }

    // 函数的调用：
    // 函数名(实参, ...) ;
    // 实参的个数和类型必须与形参的个数和类型一致
    // 函数调用时，实参的值会传递给形参，形参在函数体内使用
    // 函数调用时，实参和形参的顺序必须一致
    // 函数调用时，实参可以是变量，常量，表达式
    // 函数调用时，实参可以是函数调用
    // 函数调用时，实参可以是类型强制转换
    // 函数调用时，实参可以是取地址符&变量名（传递变量地址）
    // 函数调用时，实参可以是解引用符*指针变量名（传递指针指向的值）
    // 函数调用时，实参可以是数组名（传递数组首元素地址）
    // 函数调用时，实参可以是字符串常量（传递字符串首字符地址）
    // 函数调用时，实参可以是空（没有实参）
    // 函数调用时，实参可以是void（没有实参）


    // 函数的声明：
    // 格式：
    // 返回值类型 函数名(参数类型 参数名, ...);         
    // 函数声明告诉编译器函数的名称，返回值类型，参数类型和个数
    // 函数声明一般放在函数调用之前
    // 函数声明可以放在头文件中
    // 函数声明可以省略参数名
    


    //数组：
    //格式：
    // 数据类型 数组名[数组大小] ;
    // eg: int arr[10] ;  //定义一个包含10个整数的数组
    // 数组数据：  数组名[下标]
    // 下标从0开始，到数组大小-1结束 
    //数组的集成初始化：数组名[] = {值1, 值2, ...} ;
    //。  或： 数组名[数组大小] = {值1, 值2, ...} ;（没有给的就默认是0）
    //。                 (    = {值1，值2，[下标]=值3, ...} ;（指定下标赋值，其他默认0）
    //数组的大小： sizeof(数组名)  (输出字节数)
    //数组的元素个数：   sizeof(数组名) / sizeof(数组名[0])    永远正确！！
    //数组不能整体赋值

    //数组作为函数参数：        不能用sizeof 表示数组的大小 ，往往要引入一个新的参数表示数组的大小
    // 返回值类型 函数名(数据类型 数组名[], ...)
    // 数组名作为实参传递时，传递的是数组首元素的地址
    // 数组名作为形参时，形参的数组大小可以省略


     //二维数组：
     //定义：   类型 数组名[长][宽]
    //调用： 数组名[行][列]
    //初始化：
    //1、列数一定要给，行数可以不给
    // 2、 每行一个{}，用，隔开
    // 3、如果省略，默认补0
    //4、也可以用定位
    //eg : 
     //     int a [][5] = {
                // {1,2,3,4,5},
                // {6,7,8,9,10}
                //     }

    //. & 取地址符:   (只能取变量的地址)
    //输出地址： %p

    //数组的地址就是它第一个元素的地址
    //eg : &a[] == &a == &a[0] 
    
    
    //指针：用于保存地址的变量
    //格式：  int *p = &i      变量类型 *指针名 = &变量名   （*仅表示后面的东西是一个指针 ）
    //此时 p 为int,保存地址 ， *p 指原地址的那个变量（*作为单目运算符指访问该地址的变量）
    //可以写作： int *p,q (只有p是指针，q不是)。      或。    int* p,q
    //或 int *p , *q
    //指针在函数里的应用： 函数可以通过指针访问外面的变量 
    //  void f(int *p)     (定义)  
    //调用：  int i         f(&i)         (传参时要传地址) 
    //eg : 
    //  void f(int *p)
    //    {
    //     *p +=1;
    //    } 
    // int main()
    // {
    //     int i = 0;
        
    //     f(&i);
    //    printf("%d\n",i);
    //    return 0 ;
    // }


    //函数参数表里面的数组实际上就是指针（数组里外是一个）
    // 因此，传参时数组只是  数组名【】 ,   且不能在函数内部得到数组大小
    //数组中元素的取地址仍要用&

    /*
    传二维数组：
    1、 直接传：
    定义： 返回值类型 函数名（数组元素类型 数组名[行数][列数]）
    调用： f(数组名)

    2、指针：
    定义：返回值类型 函数名（数组元素类型 （*数组名）[列数]）

    eg:
   
void f(int a[2][2])
{
    printf("%d\n", a[1][1]);
}

int main()
{
    f(l);
    return 0 ;
}

   
   void f(int (*a)[2])
{
    printf("%d\n", a[1][1]);
}


变长数组：（C99引入，C17支持）
        1、定义时数组大小可以用变量表示 （不能是静态变量或者全局变量）
        2、变长数组不能用来初始化。（不能 int a[n] = {0};）
        3、变长数组不能用sizeof计算大小
        4、变长数组不能用来定义全局变量和静态变量
        5、变长数组只能用来定义局部变量
        6、变长数组的大小必须是正整数    
        7、可以传参：
        eg:
        void f(int rows, int cols, int a[rows][cols])




*/
    
/*重定向：
    标准输入：  键盘
    标准输出：显示器
    重定向输入：  程序从文件中读取数据  command < input.txt
    重定向输出：  程序将数据写入文件。 command > output.txt
    注：这是终端指令command为可执行文件 


    输入输出：
    getchar() :读取单个字符（包括换行符，制表符等）(return int )
    putchar(int)    ：输出单个字符
    scanf :跳过制表符换行符等，返回成功读取项的个数 ————可以用来验证输入的数字是否正确
     puts(char*): 输出字符串并自动在结尾添加换行符

    fgets(写入的字符串,读取字符的最大数量，输入来源): 读取整行遇到换行服结束并丢弃换行符,
    第二个参数为读取字符的最大数量，包括结尾的\0，如果是键盘输入则输入来源为stdin
   
    fputs(要输出的字符串,要写入的文件):第二个参数如果要显示在显示屏上则使用stdout

    fgets与fputs返回一个指向char的指针,如果一切进行顺利，该数返回的地址与传入的第一个参数相同，
    但是如果函数读到文件结尾它将返回一个空指针，
    所以可用于标识这种特殊情况在代码中可以用数字零来代替也可以用NULL来代替

    防止换行符干扰：
    1、再写一个getchar()
    2、while循环：
        while((ch = getchar()) != \n)
            continue
                注：这样会丢掉前面输入后面的所有字符

    注： 如果不修改字符串，不要用指针指向字符串的字面量

    字符串函数:
    strlen(char*)返回字符串长度
    strcat(char*,char*)拼接两个字符串，(把第二个字符串加到第一个字符串末尾)
    strncat(char*,char*,int)同上，第三个参数为拼接最大长度(不算空字符)
    bool strcmp(char*,char*) 比较两个字符串的内容
    strcpy(char* , char*)复制字符串第一个是目标字符串，第二个是原字符串返回值是char*
    该函数返回的是第一个参数的值即第一个字符的地址
    strncpy(char* , char* int)多一个参数为最大长度
    */




/*
C变量的链接：
1、外部链接：在函数外部定义，可以被其他文件访问
2、内部链接：在函数外定义，但用static修饰，只能被本文件访问
3、无链接：在函数内部定义的变量，只能在函数内部访问


stactic修饰：
1、stactic修饰的全局变量：只能被本文件访问，生命周期为整个程序运行期间
2、stactic修饰的函数：只能被本文件调用
3、stactic修饰的局部变量：只能在函数（块）内访问，生命周期为整个程序运行期间，但只能在函数（块）内访问

注：如果内层块中声明的变量与外层块中声明的变量同名，则内层块中的变量屏蔽外层块中的变量

寄存器变量：   用register修饰
1、寄存器变量储存在CPU寄存器中，访问速度更快

外部链接的变量：
在一个文件中定义，在另一个文件中用extern声明后可以使用；定义的文件与使用的文件要一起编译
也可以在定义的文件中用extern声明后使用（使用声明时的值；但其实这个做法没什么用）
也可以重新定义（会在该块隐藏全局变量）



*/


/*
    malloc() calloc() free() realloc().  :
    #include <stdlib.h>
    void* malloc(const int size): 分配指定字节大小的内存，返回void*，需要强转；
    void* calloc(const int size, const int n): 分配指定大小和数量的内存，并初始化为0，返回void*;
    void free(void* p): 释放malloc或calloc分配的内存；
    void* realloc(void* p, const int new_size): 重新分配内存 

*/


/*
restrict 关键字：
1、用于指针声明，表示该指针是唯一访问所指向数据的方式
2、用于函数参数，表示通过该指针访问的数据不会通过其他指针访问


_Atomic 关键字：声明原子类型变量：要通过各种宏函数访问原子类型，
        且当一个线程对一个原子类型对象进行原子操作时，其他线程不能对该对象进行任何操作

*/


/*

文件输入与输出：

1、读写模式：
    1、文本模式：会对文件里的不同操作系统的特殊字符（换行符不同）进行转换，统一换成C模式的（换行符为\n）
    2、二进制模式：不进行转换，按照原样读写

1.5、相关的：
    1、命令行参数： int main(int argc, char* argv[] )
    argc: 命令行中（argv中）字符串的数量
    argv: 命令行输入的字符串数组,以空格为分格 argv[0]为文件名
    eg: (123.exe)
    ./123.exe I'm fine
    有： argv[0] = "可执行文件名"("123")
        argv[1] = "I'm"
        argv[2] = "fine"
        
    exit() : (#include stdlib)
    作用：关闭所有打开的文件并结束程序，将传入的参数传递给操作系统
    参数： 0    EXIT_SUCCESS    EXIT_FAILURE

2、标准I/O函数：
    1、 FILE* fopen(char* file_path , char* opening_mode ) : 以指定的形式打开文件,返回文件指针
    模式： 
        "r" : 只读
        "w" : 只写（清空现有文件，如果文件不存在则创建）
        "a" : 写模式（在文件尾添加，如果文件不存在则创建）
        "r+" : 更新模式（可读写）
        "w+" : 更新模式，清空现有文件
        "a+" : 更新模式，只在末尾添加
        "rb" "wb" "ab" "rb+" "r+b" "wb+" "w+b" "ab+" "a+b" :同上，以二进制模式打开
        "wx" "wbx" "w+x" "wb+x" "w+bx" ：以非x模式，但是如果文件已经存在或者以独占模式打开，则打开失败

    2、 int getc(FILE* file_path) : 和getchar()一致
    
    3、 putc(int ch , FILE* file_path) : 和putchar()一致
    
    4、 int fclose(FILE* file_path) : 关闭指定文件，如果成功关闭则返回0，否则返回EOF
    
    5、 fprintf(FILE* file_path, 输出内容) : same as printf
            eg:抛出错误 : fprintf(stderr, "ERROR");
    
    6、 fscanf(FILE* file_path , 输入内容) : same as scanf
    
    7、 rewind(FILE* file_path) : 将光标回到文件开头
    
    8、 fgets(char* 结果保存的字符串名, int length , FILE* file_path): 
        读取到第一个换行符（一行，不会丢掉换行符）或读取length-1个字母，或读到文件末尾， 最后在末尾加一个\0
        fgets()如果读到EOF则返回NULL否则返回传给他的地址
    
    9、fputs(char* 输出的字符串名 , FILE* file_path) : 输出一整个字符串，不会在末尾加换行符（可以和fgets()末尾不去掉换行符配合）
    
    10、 int fseek(FILE* file_path , long 偏移量 , enum 模式)
    偏移量：相对起始点的偏移量（正为前移，负为后移，0不动）
    模式：
        SEEK_SET ： 文件起始点  （0L）
        SEEK_CUR ： 当前位置    （1L）
        SEEK_END ： 文件末尾    （2L）
    eg:
        fseek(fp , 0L , SEEK_SET) ：文件开始处
        fseek(fp , 23L , SEEK_SET) : 第23字节处
        fseek(fp , 2L , SEEK_CUR) : 当前位置前进2个字节
        fseek(fp , 0L , SEEK_END) : 文件末尾
        fseek(fp , -10L , SEEK_END) : 文件末尾回退10个字节
    
    11、 long ftell(FILE* file_path) 
            返回当前位置（距文件开始处的字节数 ， 二进制文件时：文件的第一个字节到文件开始处距离为0）
    注：“当前位置” 指光标位置，可以用fseek设置
        eg：获取文件一共有多少字节：
        fseek(fp , 0L , SEEK_END);
        long last = ftell(fp);
    对于文本模式，许多系统的文本文件格式与UNIX模型差很多，导致从文件开始处统计的字节数成为一个毫无意义的值
    对于文本模式，ftell的返回值可以作为fseek的第二个参数，对于MS-DOS ftell()的返回值把\r\n作为一个字节计数

    12、int fgetpos(FILE* file_path , const fpos_t *p) : 用于取得超大文件的位置，成功返回0，失败返回非0
    fpos_t : 不是基本类型，可以在文件中指定一个位置，它不能是 数组类型，除此之外没有限制

    13、int fsetpos(FILE* stream , const fpos_t *pos) : 设定光标位置 ， 成功返回0，失败返回非0
    设定光标于 *pos 的位置



3、文件结尾： 读取一个字符发现是文件结尾时返回EOF
    注：C只有在读到超过文件结尾时才会发现文件的结尾  
    

4、指向标准文件的指针：
    标准输入：  stdin   （通常）键盘
    标准输出：  stdout   （通常）显示器
    标准错误：  stderr    （通常）显示器 -> 就算已经重定向或者打开文件，错误一般还是以显示器输出

5、二进制模式和文本模式：
    UNIX只有一种文件格式，无需进行特殊的转换

    MS-DOS ：
    1、很多编辑器用Ctrl+Z字符标记文本文件的结尾，以文本模式打开时，C能识别这个作为文件结尾；但是作为二进制模式打开相同的文件时
    Ctrl+Z看作字符，文件结尾可能紧跟着在后面，也可能隔着一堆\0使文件大小是256的倍数
    2、使用\r\n组合表示文件换行，以文本模式打开时C会自动转换为\n，但是如果以二进制模式打开时不会转换，因此要加上监测代码：
            if(ch != CNTL_Z && ch != '\r')

6、其他标准IO函数：

    1、 int ungetc(int c, FILE *fp) : 将一个字符放回输入流

    2、 int fflush(FILE *fp) : 刷新输出缓冲区（将缓冲区所有没有写入的数据发送到fp指定的输出文件（不能用于输入流）
        只要最近一次操作不是输入操作，就可以用该函数更新流
    
    3、 int setvbuf(FILE* fp , char* buf , int mode , size_t size) : 创建一个供标准IO函数使用的缓冲区
        在打开文件后且未对流进行其他操作之前调用该函数， 成功返回0，失败返回非0
        fp : 待处理的流
        buf : 待使用的缓冲区 ，如果buf的值不是NULL则必须创建一个缓冲区（比如声明一个char[]给buf），如果是NULL则会自己创建一个缓冲区
        size ：告诉setvbuf() 数组的大小 （size_t是sizeof（）返回值的类型）
        mode ： 
            _IOFBF : 完全缓冲（缓冲区满刷新）
            _IOLBF : 行缓冲（缓冲区满或者写入一个换行符）
            _IONBF : 无缓冲
    
    4、size_t fwrite(void* ptr, size_t size , size_t nmemb,FILE* fp) : 二进制保存（不将数值转换成字符）
        ptr ：待写入数据块的地址
        size ： 写入数据块的大小（字节）
        nmemb ： 待写入数据块的数量
        fp ：写入的文件

            eg:写入一个256字节的对象（如数组）：
                char buffer[256];
                fwrite(buffer, 256 ,1,fp)
            内含10个元素的double数组：
                double a[10];
                fwrite(a, sizeof(double) , 10 , fp);

        返回成功写入项的数量

    5、size_t fread(void* ptr , size_t size , size_t nmemb , FILE* fp)
        参数同上

    6、 int feof(FILE* fp)
        int ferror(FILE* fp)
        如果标准输入到达函数结尾和出行读取错误时就会返回EOF
        当上一次输入调用到文件结尾时，feof()返回一个非0值，否则返回0
        当读或写出现错误，ferror()返回一个非0值，否则返回0
    

*/

/*

结构体

    传递结构体的地址时，结构体名不能看作指针要用&取地址
    
    复合字面量（一个不需要声明的结构体变量）
    格式： （数据类型）{初始化内容}
    eg:  struct abc
    {
        char name[20];
        int age;
    } ;
    void 需要abc的函数(struct abc);
    
    需要abc的函数( (struct abc) {"lihua" , 20} );


    伸缩型数组：结构体中初始化时没有规定长度的数组
    要求： 必须是结构体的最后一个元素
          必须搭配指针与malloc使用

    格式：
    1、声明：struct my_structure{
                int a;
                int flex[];
                };
    2、分配内存（内存没有分配时无法使用）：
        struct my_structure *p;
        *p = (struct my_structure*)malloc(1*sizeof(int) + 10*sizeof(int))       //此时flex分配10个int的长度

    3、正常使用（可以使一个结构体有不同长度的数组）


    储存记录：
    最好使用fwrite与fread
    eg:要储存struct abcde hijk

    fwrite(&hijk , sizeof(struct abcde) , 1 , fp);




    联合数据类型：
    类似结构体，但是只能储存一个数据（一种能够储存一堆数据类型的变量）

    union hold
    {
        int a;
        char b;
        double c;
    };

    使用与结构体一样



    复杂声明：
    规则：
    1、[]  与 （）同级，且优先级比 * 高
    2、同级从左往右结合

    eg:
    1、  int * a[10]    a是一个数组，包含10个指针（[] 的优先级更高）
    2、  int (* a)[10]  a是一个指针，指向长度为10 的数组（从左往右）
    3、  int (* a)[10][20]  a是一个指针，指向10*20的二维数组

    带函数的：
    eg:
    1、 char * f(int)   声明一个返回char的函数
    2、 char (* f)(int) 声明一个函数指针，函数返回char
    3、 char (* f[3])(int)  声明一个长度为3的函数指针数组，函数返回char



    函数指针：
    格式：
    声明：
        返回值 (*指针名)（参数类型）
    赋值：
        指针 = (同类型函数的)函数名；
    eg:   void ToUpper(char *);
          void (* pf)(char *);
          pf = ToUpper;
*/


/*
位操作：
1、位逻辑操作：
    1、按位反    ～（a）
    2、按位与   （a）&（b）
    3、按位或    （a) | (b)
    4、按位异或     (a) ^ (b)



掩码（相当于蒙版）
原理： 0 & a = 0
      1 & a = a

    操作：
    1、打开位：（将要打开的位的掩码设置为1，其他为0 ，用&）
        eg:打开第3位与第5位
        int mask = 20; (二进制 00010100)
        a &= mask;
    
    2、关闭位：（将打开位的掩码取反）
        eg:
        a &= (~mask);

    3、切换位（掩码要切换的位设置为1，其余为0 ， 用^）
        eg:
        a ^= mask;(将a第三位与第五位的0换为1，1换为0)
    
    4、检查位的值（将要检查位的掩码设置为1，其余为0，&运算后与掩码比较） //检查该位是否为1
        eg:
        if((a & mask) == mask)


2、移位操作：
    1、左移位： <<
    （a） << b      //把a左移b位 （超出位数限制的丢掉，用0来补充空）（加法器的进位输出、乘以2的n次幂）

    2、右移位： >>
        (a) >> b    （除以2的n次幂）



*/



